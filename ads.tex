\documentclass[a4paper,11pt]{article}
\usepackage{skis}
\begin{document}

\section{Бинарное дерево поиска}

В каждом узле ключ и два поддерева. Все ключи в левом поддереве $\le$ ключа в данном узле, в правом — $\ge$. Алгоритм поиска — начиная с корня, сравниваем с ключом в узле.

Вставка в бинарное дерево — поиск + вставляем туда, куда пришёл поиск. Чтобы удалить элемент --- ставим на его место самый левый элемент в его правом поддереве.

Проблема такой наивной структуры — может вместо дерева получиться палка, и поиск будет занимать $O(n)$. Красно-чёрные деревья, например, следят за тем, чтобы дерево всегда имело высоту $O(\log n)$.

Хотим научиться поддерживать $\pm$баланс, не храня много дополнительной информации (в духе, атрибутов red/black). Это умеют две структуры.

\section{Scape goat tree}

Зафиксируем константу $\frac{1}{2} \le \alpha < 1$. Желаемая высота дерева (если $n$ — количество узлов с ключами) —
$$\left\lfloor \log_{\frac{1}{\alpha}} n \right\rfloor + 1= H+1.$$

Если $\alpha = \frac{1}{2}$, то результатом будет идеально сбалансированное дерево, то есть $\alpha$ — это, грубо говоря, разрешённое отклонение размера поддеревьев от баланса.

Узел называется {\it глубоким,} если его глубина не меньше $H$. Инвариант, который будем поддерживать —
	$$\mathrm{size} (x.\text{left}) \le \alpha \cdot \mathrm{size} (x.\text{right}).$$

Дерево с таким инвариантом называется $\alpha$-weight balanced. Если weight balanced, то и $\alpha$-height balanced (то есть высота не превосходит $H$). Обратного следствия нет, потому что может быть «один сын справа, а слева сбалансированное поддерево».

Поиск в такой структуре занимает $\log n$ — это очевидно, если инвариант выдержан. Вставка и удаление требуют частичной перестройки дерева.

У узла node есть родитель parent, дети left, right и ключ key. У дерева tree есть size — количество узлов, а также maxSize. maxSize — штука, которая не больше, чем максимальный размер дерева с данной идеальной высотой.

{\it Инвариант:} $\alpha \cdot \text{maxSize} \le \text{size} (T) \le \text{maxSize}$ — это про размер всего единого дерева. Действительно, храним вот только два числа.

{\it Удаление:} просто удаляем. Проверяем, не нарушился ли инвариант. Если нарушился — просто перестроим всё дерево с нуля, сделав массив с ключами за линию и соорудив из него идеально сбалансированное дерево. size при этом уменьшается на 1, а maxSize $=$ size.

{\it Вставка:} сначала стандартная вставка, добавляем ключ в лист. При этом size увеличивается на 1,
	$$\text{maxSize} \coloneqq \max (\text{maxSize},\text{size}).$$

Может, однако, оказаться так, что новый узел $x$ оказался глубоким (на максимально разрешённой глубине $H+1$). Тогда рассмотрим путь от $x$ до корня $a_1 \ldots a_{H+1}$ и найдём среди этих узлов (просто за линию, посчитав количество) самый нижний, не сбалансированный по весу (такой найдётся, докажем) и перестраиваем (глупо, за линию) дерево под ним.

\begin{theorem}
	Среди $a_1 \ldots a_{H+1}$ всегда найдётся узел, не сбалансированный по весу (козёл отпущения).
\end{theorem}

\begin{proof}
	Пусть нет, тогда $\text{size} (a_i) \le \alpha \cdot \text{size} (a_{i+1})$. Тогда $\text{size} (x) \le \alpha^H \cdot \text{size} (T)$. Прологарифмируем это неравенство по основанию $\frac{1}{n}$:
	$$0 \le -H + \log_{\frac{1}{\alpha}} n$$
\end{proof}

\begin{theorem}
	При удалении элемента сохраняется сбалансированность по высоте.
\end{theorem}

\begin{proof}
	Пусть
	$$h(T) > \left\lfloor \log_{\frac{1}{\alpha}} n \right\rfloor.$$
\end{proof}






























\end{document}
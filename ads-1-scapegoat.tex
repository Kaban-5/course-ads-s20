\section{Бинарное дерево поиска}

В каждом узле бинарного дерева поиска хранятся {\it ключ $a$} и два поддерева, правое и левое. Все ключи в левом поддереве не превосходят $a$, а в правом — не меньше $a$. Алгоритм поиска — начиная с корня, сравниваем искомый ключ с ключом в узле, в зависимости от сравнения спускаемся в правое или в левое поддерево.

Вставка в бинарное дерево — поиск $+$ вставляем туда, куда пришёл поиск. Чтобы удалить элемент --- ставим на его место самый левый элемент в его правом поддереве.

Проблема такой наивной структуры — может вместо дерева получиться палка (если, например, ключи приходят в порядке по убыванию), и поиск будет занимать $\BigO(n)$. Красно-чёрные деревья, например, следят за тем, чтобы дерево всегда имело высоту $\BigO(\log n)$.

Хотим научиться поддерживать $\pm$баланс, не храня много дополнительной информации (такой, как атрибуты red/black) — в идеале, $\BigO(1)$ дополнительных данных, какие-нибудь несколько чисел про дерево в целом. Это умеют две структуры.

\section{Scapegoat tree}

{\it Источники: \cite{galperin1993scapegoat,andersson1989improving}. Мы в основном опираемся на \cite{galperin1993scapegoat}.}

Зафиксируем константу $\frac{1}{2} \le \alpha < 1$. Будем рассматривать структуру данных, в которой храниться дерево tree. Также будем хранить текущее количество узлов в дереве — size. У каждого узла node есть родитель parent, дети left, right и ключ key.

Желаемая максимальная высота дерева ($n$~— количество узлов с ключами)~—

\begin{equation*}
	\floor*{ \log_{\frac{1}{\alpha}} n } + 1 = H + 1.
\end{equation*}


Если $\alpha = \frac{1}{2}$, то результатом будет идеально сбалансированное дерево, то есть $\alpha$ — это, грубо говоря, разрешённое отклонение размера поддеревьев от состояния баланса.

Узел называется {\it глубоким,} если его глубина не меньше $H$. Свойство дерева, которое нам хотелось бы поддерживать —

\begin{equation*}
	\size (x.\text{left}) \le \alpha \cdot \size (x.\text{right}).
\end{equation*}

Дерево с таким свойством называется $\alpha$-weight balanced. Если weight balanced, то и $\alpha$-height balanced (то есть высота не превосходит $H$). Обратного следствия нет, потому что может быть «один сын справа, а слева сбалансированное поддерево».

Поиск в $\alpha$-сбалансированном дереве занимает $\log n$ времени — это очевидно, если инвариант выдержан. Вставка и удаление требуют частичной перестройки дерева.

Чтобы реализовать вставку и удаление, нам также потребуется хранить величину maxSize для всего дерева tree. maxSize — штука, которая не больше, чем максимальный размер дерева с данной идеальной высотой. (То есть, кроме собственно дерева с ключами, мы храним дополнительно только size и maxSize — два числа.)

{\it Инвариант:} $\alpha \cdot \text{maxSize} \le \text{size} (T) \le \text{maxSize}$ — это про размер всего единого дерева.

{\it Удаление:} просто удаляем. Проверяем, не нарушился ли инвариант. Если нарушился — просто перестроим всё дерево с нуля, сделав массив с ключами за линию и соорудив из него идеально сбалансированное дерево. size при этом уменьшается на 1, а maxSize $=$ size.

{\it Вставка:} сначала стандартная вставка, добавляем ключ в лист. При этом size увеличивается на 1,

\begin{equation*}
	\text{maxSize} \coloneqq \max (\text{maxSize},\text{size}).
\end{equation*}

Может, однако, оказаться так, что новый узел $x$ оказался глубоким (на максимально разрешённой глубине $H+1$). Тогда рассмотрим путь от $x$ до корня $a_1 \ldots a_{H+1}$ и найдём среди этих узлов (просто за линию, посчитав количество) самый нижний, не сбалансированный по весу (такой найдётся, докажем) и перестраиваем (глупо, за линию) дерево под ним.

\begin{theorem}
	Среди $a_1 \ldots a_{H+1}$ всегда найдётся узел, не сбалансированный по весу (козёл отпущения).
\end{theorem}

\begin{proof}
	Пусть нет, тогда $\text{size} (a_i) \le \alpha \cdot \text{size} (a_{i+1})$. Тогда $\text{size} (x) \le \alpha^H \cdot \text{size} (T)$. Прологарифмируем это неравенство по основанию $\frac{1}{n}$:

	\begin{equation*}
		0 \le -H + \log_{\frac{1}{\alpha}} n		
	\end{equation*}
\end{proof}

\begin{theorem}
	При удалении элемента сохраняется сбалансированность по высоте.
 \end{theorem}
